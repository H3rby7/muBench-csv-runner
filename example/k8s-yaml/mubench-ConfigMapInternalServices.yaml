apiVersion: v1
data:
  {
    "Loader.py": "import random\nimport time\nimport os\nfrom concurrent.futures import ThreadPoolExecutor, wait\nimport jsonmerge\nimport string\n\nparams_processed = False\nparams = dict()\n\ndef cpu_loader_job(params):\n    cpu_load = random.randint(params[\"range_complexity\"][0], params[\"range_complexity\"][1])\n    trials = int(params[\"trials\"])\n\n    for x in range(trials):\n        pi_greco = list()\n        q, r, t, k, m, x = 1, 0, 1, 1, 3, 3\n        counter = 0\n        while True:\n            if 4 * q + r - t < m * t:\n                # yield m\n                pi_greco.append(str(m))\n                q, r, t, k, m, x = 10*q, 10*(r-m*t), t, k, (10*(3*q+r))//t - 10*m, x\n                if counter > cpu_load-1:\n                    break\n                else:\n                    counter = counter+1\n            else:\n                q, r, t, k, m, x = q*k, (2*q+r)*x, t*x, k+1, (q*(7*k+2)+r*x)//(t*x), x+2\n        #print(\"Service complexity: %d - Number of cycles for pi computation: %d\" % (cpu_load, cpu_load + 1))\n        # print(f\"Value: 3.{''.join(pi_greco[1:])}\\n\")\n\ndef cpu_loader(params):\n    # print(\"--------> CPU stress start\")\n    pool_size = int(params[\"thread_pool_size\"])\n    pool = ThreadPoolExecutor(pool_size)\n    futures = list()\n    for thread in range(pool_size):\n        futures.append(pool.submit(cpu_loader_job, params))\n    wait(futures)\n    # print(\"--------> CPU stress test stop\")\n    return\n\ndef bandwidth_loader(params):\n    # print(\"--------> Network stress start\")\n    bandwidth_load = random.expovariate(1 / params[\"mean_response_size\"])\n    num_chars = int(max(1, 1000 * bandwidth_load))  # Response in kB\n    response_body = ''.join(random.choice(string.ascii_letters) for i in range(num_chars))\n    # print(\"--------> Network stress stop\")\n    return response_body\n\ndef memory_loader(params):\n    # print(\"--------> Memory stress start\")\n    memory_size = params[\"memory_size\"]\n    memory_io = params[\"memory_io\"]\n    \n    # allocate memory_size kB of memory\n    dummy_buffer = []\n    dummy_buffer = ['A' * 1000 for _ in range(0, int(memory_size))]\n    \n    for i in range(0, int(memory_io)):\n        v = dummy_buffer[i % int(memory_size)]  # read operation\n        dummy_buffer[i % int(memory_size)] = ['A' * 1000] # write operation\n    # print(\"--------> Memory stress stop\")\n    return dummy_buffer\n\ndef disk_loader(params):\n        # print(\"--------> Disk stress start\")\n        # print(\"--------> Write stress start\")\n        filename_base = params[\"tmp_file_name\"]\n        rnd_str = ''.join(random.choice(string.ascii_lowercase) for i in range(10))\n        filename = f\"{rnd_str}-{filename_base}\"\n        blocks_count = params[\"disk_write_block_count\"]\n        block_size = params[\"disk_write_block_size\"]\n        f = os.open(filename, os.O_CREAT | os.O_WRONLY, 0o777)  # low-level I/O\n        for i in range(blocks_count):\n            buff = os.urandom(block_size)\n            os.write(f, buff)\n        os.fsync(f)  # force write to disk\n        os.close(f)\n        # print(\"--------> Write stress stop\")\n\n        # print(\"--------> Read stress start\")\n        f = os.open(filename, os.O_RDONLY, 0o777)  # low-level I/O\n        # generate random read positions\n        offsets = list(range(0, blocks_count * block_size, block_size))\n        random.shuffle(offsets)\n\n        for i, offset in enumerate(offsets, 1):\n            os.lseek(f, offset, os.SEEK_SET)  # set position\n            buff = os.read(f, block_size)  # read from position\n            if not buff: break  # if EOF reached\n        os.close(f)\n        # print(\"--------> Read stress stop\")\n        os.remove(filename)\n        return\n\ndef sleep_loader(params):\n    # print(\"--------> Sleep start\")\n    time.sleep(float(params[\"sleep_time\"]))\n    # print(\"--------> Sleep stop\")\n    return\n\ndef loader(input_params):\n    global params_processed, params\n\n    if not params_processed:\n        default_params = {\n            \"cpu_stress\": {\"run\":False,\"range_complexity\": [100, 100], \"thread_pool_size\": 1, \"trials\": 1},\n            \"memory_stress\":{\"run\":False, \"memory_size\": 10000, \"memory_io\": 1000},\n            \"disk_stress\":{\"run\":False,\"tmp_file_name\":  \"mubtestfile.txt\", \"disk_write_block_count\": 1000, \"disk_write_block_size\": 1024},\n            \"sleep_stress\":{\"run\":True,\"sleep_time\": 0.01},\n            \"mean_response_size\": 11}\n\n        params = jsonmerge.merge(default_params,input_params)\n        if \"mean_bandwidth\" in params:\n            # for backward compatibility\n            params[\"mean_response_size\"] = params[\"mean_bandwidth\"]\n        params_processed = True    \n    if params['cpu_stress']['run']: \n        cpu_loader(params['cpu_stress'])\n    if params['memory_stress']['run']:\n        memory_loader(params['memory_stress'])\n    if params['disk_stress']['run']:\n        disk_loader(params['disk_stress'])\n    return bandwidth_loader(params)\n\nif __name__ == '__main__':\n    loader({})",
    "LICENSE": "BSD 4-Clause License\n\nCopyright (c) 2021, University of Rome Tor Vergata\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n * Redistributions of source code must retain the above copyright notice,\n   this list of conditions and the following disclaimer.\n * Redistributions in binary form must reproduce the above copyright\n   notice, this list of conditions and the following disclaimer in the\n   documentation and/or other materials provided with the distribution.\n * All advertising materials mentioning features or use of this software\n   must display the following acknowledgement: This product includes\n   software developed by University of Rome Tor Vergata and its contributors.\n * Neither the name of University of Rome Tor Vergata nor the names of its\n   contributors may be used to endorse or promote products derived from\n   this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\nCONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\nSUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\nINTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\nCONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\nARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGE.",
  }
kind: ConfigMap
metadata:
  name: internal-services
  namespace: mubench
  labels:
    component: mubench
